#!/usr/bin/env python3

import os
import shutil
import subprocess
import sys
from typing import List
from pathlib import Path


# ----------------------------------------------------------------------------
# GLOBAL SETTINGS
# ----------------------------------------------------------------------------

APP_NAME: str = "pygls"
APP_ROOT_PACKAGE: str = APP_NAME
LOCALE_DOMAIN: str = APP_NAME

# full relative paths to the locale files.
VALID_LOCALES: List[str] = ['pt_BR', 'en_US']
LOCALE_DIR: str = 'locale'
LOCALE_POT: str = os.path.join(LOCALE_DIR, LOCALE_DOMAIN + '.pot')


# ----------------------------------------------------------------------
# OS PROCESS HELPERS
# ----------------------------------------------------------------------

def run_command(command_args: List[str], silent: bool = False) -> bool:
    """
    Runs any shell command using the subprocess module, ensuring cross-platform compatibility.

    Args:
        command_args (List[str]): A list of strings representing the command and its arguments.

        silent (bool): If True, suppresses output unless an error occurs.

    Returns:
        bool: True if the command executed successfully, False otherwise.
    """
    if not silent:
        print(f"--- Running:  {' '.join(command_args)}")

    try:
        # Use subprocess.run to execute the command.
        # check=True raises an exception for non-zero return codes (errors).
        # Using a list for the command ensures cross-platform compatibility.
        result = subprocess.run(
            command_args,
            check=True,
            capture_output=True,
            text=True
        )

        if not silent:
            # Print the standard output and error output from the command
            if result.stdout:
                print(result.stdout.strip())
            if result.stderr:
                print(result.stderr.strip(), file=sys.stderr)

        print("\n✅ Command executed successfully.")
        return True

    except subprocess.CalledProcessError as e:
        print(f"\n❌ Error running shell command (Exit Code {e.returncode}):", file=sys.stderr)
        if e.stdout:
            print("--- STDOUT (Context) ---", file=sys.stderr)
            print(e.stdout.strip(), file=sys.stderr)
        if e.stderr:
            print("--- STDERR (Details) ---", file=sys.stderr)
            print(e.stderr.strip(), file=sys.stderr)
        return False

    except FileNotFoundError:
        # This occurs if command executable is not found in the system's PATH
        print("\n❌ Error: The command executable was not found.", file=sys.stderr)
        return False

    except Exception as e:
        print(f"\n❌ An unexpected error occurred: {e}", file=sys.stderr)
        return False

    finally:
        print("\n" + "="*50 + "\n")


def run_pybabel_command(pybabel_args: List[str], silent: bool = False) -> bool:
    """
    Runs any pybabel command using the subprocess module, ensuring cross-platform compatibility.

    Args:
        pybabel_args (List[str]): A list of strings representing the pybabel command and its arguments,
                                    e.g., ['extract', '-o', 'messages.pot', '.'].
                                    **Do NOT include 'pybabel' itself.**

        silent (bool): If True, suppresses output unless an error occurs.

    Returns:
        bool: True if the command executed successfully, False otherwise.
    """
    # The full command starts with the 'pybabel' executable.
    command = ['pybabel'] + pybabel_args

    return run_command(command, silent)


def copy_files_recursive(source_dir: str, dest_dir: str):
    """
    Copies all files from source_dir and its subfolders to dest_dir,
    preserving the original folder structure.

    Args:
        source_dir (str): The origin directory to copy files from.
        dest_dir (str): The target directory to copy files to.
    """
    # Ensure source directory exists
    if not os.path.isdir(source_dir):
        print(f"Error: Source directory not found: {source_dir}")
        return

    # Ensure destination directory exists (or create it)
    os.makedirs(dest_dir, exist_ok=True)
    print(f"Starting copy from '{source_dir}' to '{dest_dir}'...")

    # os.walk generates the file names in a directory tree
    # by walking the tree either top-down or bottom-up.
    for root, _, files in os.walk(source_dir):
        # 1. Calculate the path relative to the source directory
        # This tells us us the folder structure we need to recreate.
        relative_path = os.path.relpath(root, source_dir)

        # 2. Create the corresponding target directory path
        target_dir = os.path.join(dest_dir, relative_path)

        # 3. Create the target directory if it doesn't exist
        # 'exist_ok=True' prevents an error if the directory already exists.
        os.makedirs(target_dir, exist_ok=True)
        # Note: We create directories even if they contain no files,
        # which is usually desired to preserve the full structure.

        # 4. Copy all files in the current directory (root)
        for file_name in files:
            source_file = os.path.join(root, file_name)
            dest_file = os.path.join(target_dir, file_name)

            try:
                # shutil.copy2 copies the file data and metadata.
                # IMPORTANT: shutil.copy2 will automatically OVERWRITE 
                # the destination file if it already exists.
                shutil.copy2(source_file, dest_file)
                print(f"\tCopied: {relative_path}/{file_name}")
            except Exception as e:
                print(f"\tError copying {source_file}: {e}")

    print("Copy process finished.\n")


# ----------------------------------------------------------------------------
# ENTRY-POINT CHECK
# ----------------------------------------------------------------------------

# This module cannot be loaded by another module.
if __name__ != "__main__":
    sys.exit("This module 'pylocale' cannot be loaded by another module.")
# proceeds only if this program was executed as entry-point...

#  Get the current working directory and extract the last part of the path.
current_dir = os.getcwd()
current_dir_name = os.path.basename(current_dir)

# Check if the current directory is not root of project.
if current_dir_name == "tools":
    # Change the current working directory to the parent directory (root of project).
    parent_dir = os.path.join(current_dir, '..')
    os.chdir(parent_dir)
    print(f"✅ Detected running from **/tools. Changed directory to: {os.getcwd()}\n")


# ----------------------------------------------------------------------
# APP LOCALIZATION / I18N
# ----------------------------------------------------------------------

result_ok: bool = False

# --- Extract English strings → messages.pot
# Equivalent to:  pybabel extract -F babel.cfg -o locale/messages.pot .
result_ok = run_pybabel_command(['extract', '-F', 'tools/babel.cfg', '-o', LOCALE_POT, '.'])
if not result_ok:
    print("\n🚨 Please ensure **Babel** is installed in your environment (e.g., `pip install Babel`).", file=sys.stderr)
    sys.exit(1)

# Check if the directory structure and the file already exist.
en_us_messages_path: str = os.path.join('locale', 'en_US', 'LC_MESSAGES', LOCALE_DOMAIN + '.po')
if os.path.exists(en_us_messages_path) and os.path.isfile(en_us_messages_path):
    # --- Update a .po translation file.
    # Equivalent to:  pybabel update -D messages -i locale/messages.pot -d locale
    result_ok = run_pybabel_command(['update', '-D', LOCALE_DOMAIN, '-i', LOCALE_POT, '-d', LOCALE_DIR])
    if not result_ok: sys.exit(1)

    # --- Review, edit, and remove translations marked as fuzzy: #, fuzzy
    # Equivalent to:  grep -n -i -H -r --include="*.po" "fuzzy" locale
    run_command(['grep', '-n', '-i', '-H', '-r', '--include="*.po"', '"fuzzy"', LOCALE_DIR])

else:
    # --- Initialize each language catalog → locale/idiom/LC_MESSAGES/messages.po 
    # Equivalent to:  pybabel init -D messages -i src/app/locale/messages.pot -d src/app/locale -l language
    # NOTE: Recommended even if English is source. This allows translators 
    # to correct source English if needed.
    for idiom in VALID_LOCALES:
        result_ok = run_pybabel_command(['init', '-D', LOCALE_DOMAIN, '-i', LOCALE_POT, '-d', LOCALE_DIR, '-l', idiom])
        if not result_ok: sys.exit(1)

# --- Compile .po → .mo
# The gettext runtime system uses binary .mo files, so you must compile the .po files.
# Equivalent to:  pybabel compile -D messages -d locale
# NOTE: This will fail if 'messages.po' from the previous command doesn't exist.
result_ok = run_pybabel_command(['compile', '-D', LOCALE_DOMAIN, '-d', LOCALE_DIR])
if not result_ok: sys.exit(1)

# --- Update locales of projects using this library:
copy_files_recursive('locale', '../nasa/src/nasa/locale')

# everything ok!
sys.exit(0)
